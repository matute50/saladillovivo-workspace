#!/usr/bin/env -S deno run --allow-read --allow-write

/**
 * Service Worker Scaffolder
 *
 * Generates service worker code based on selected caching strategy and framework.
 * Supports vanilla JS, Workbox, and Vite PWA plugin configurations.
 *
 * Usage:
 *   deno run --allow-read --allow-write sw-scaffolder.ts --strategy cache-first
 *   deno run --allow-read --allow-write sw-scaffolder.ts --framework workbox --output sw.js
 *   deno run --allow-read --allow-write sw-scaffolder.ts --routes routes.json
 */

// === INTERFACES ===

type CachingStrategy = "cache-first" | "network-first" | "stale-while-revalidate" | "network-only" | "cache-only";
type Framework = "vanilla" | "workbox" | "vite-pwa" | "sveltekit";

interface RouteConfig {
  pattern: string;
  strategy: CachingStrategy;
  cacheName?: string;
  maxAge?: number;
  maxEntries?: number;
}

interface ScaffolderConfig {
  strategy: CachingStrategy;
  framework: Framework;
  routes?: RouteConfig[];
  cacheName?: string;
  precacheUrls?: string[];
  offlineFallback?: string;
  skipWaiting?: boolean;
  clientsClaim?: boolean;
}

// === TEMPLATES ===

const VANILLA_TEMPLATE = `// Service Worker - Generated by pwa-development skill
// Strategy: {{STRATEGY}}

const CACHE_NAME = '{{CACHE_NAME}}';
const CACHE_VERSION = 'v1';
const FULL_CACHE_NAME = \`\${CACHE_NAME}-\${CACHE_VERSION}\`;

// URLs to precache during install
const PRECACHE_URLS = [
{{PRECACHE_URLS}}
];

// Offline fallback page
const OFFLINE_FALLBACK = '{{OFFLINE_FALLBACK}}';

// Install event - precache assets
self.addEventListener('install', (event) => {
  console.log('[SW] Install event');
  event.waitUntil(
    caches.open(FULL_CACHE_NAME)
      .then((cache) => {
        console.log('[SW] Precaching assets');
        return cache.addAll(PRECACHE_URLS);
      })
      .then(() => {
        {{SKIP_WAITING}}
      })
  );
});

// Activate event - clean up old caches
self.addEventListener('activate', (event) => {
  console.log('[SW] Activate event');
  event.waitUntil(
    caches.keys()
      .then((cacheNames) => {
        return Promise.all(
          cacheNames
            .filter((name) => name.startsWith(CACHE_NAME) && name !== FULL_CACHE_NAME)
            .map((name) => {
              console.log('[SW] Deleting old cache:', name);
              return caches.delete(name);
            })
        );
      })
      .then(() => {
        {{CLIENTS_CLAIM}}
      })
  );
});

// Fetch event - apply caching strategy
self.addEventListener('fetch', (event) => {
  // Skip non-GET requests
  if (event.request.method !== 'GET') {
    return;
  }

  // Skip cross-origin requests
  if (!event.request.url.startsWith(self.location.origin)) {
    return;
  }

  event.respondWith(
    {{FETCH_HANDLER}}
  );
});

// Handle offline fallback
async function handleOffline(request) {
  if (request.mode === 'navigate' && OFFLINE_FALLBACK) {
    const cache = await caches.open(FULL_CACHE_NAME);
    return cache.match(OFFLINE_FALLBACK);
  }
  return new Response('Offline', { status: 503, statusText: 'Service Unavailable' });
}
`;

const FETCH_HANDLERS: Record<CachingStrategy, string> = {
  "cache-first": `
    caches.match(event.request)
      .then((cachedResponse) => {
        if (cachedResponse) {
          return cachedResponse;
        }
        return fetch(event.request)
          .then((response) => {
            // Don't cache non-success responses
            if (!response || response.status !== 200 || response.type !== 'basic') {
              return response;
            }
            // Clone response for caching
            const responseToCache = response.clone();
            caches.open(FULL_CACHE_NAME)
              .then((cache) => cache.put(event.request, responseToCache));
            return response;
          })
          .catch(() => handleOffline(event.request));
      })
  `,
  "network-first": `
    fetch(event.request)
      .then((response) => {
        if (!response || response.status !== 200) {
          throw new Error('Network response not ok');
        }
        const responseToCache = response.clone();
        caches.open(FULL_CACHE_NAME)
          .then((cache) => cache.put(event.request, responseToCache));
        return response;
      })
      .catch(() => {
        return caches.match(event.request)
          .then((cachedResponse) => {
            if (cachedResponse) {
              return cachedResponse;
            }
            return handleOffline(event.request);
          });
      })
  `,
  "stale-while-revalidate": `
    caches.match(event.request)
      .then((cachedResponse) => {
        const fetchPromise = fetch(event.request)
          .then((response) => {
            if (response && response.status === 200) {
              const responseToCache = response.clone();
              caches.open(FULL_CACHE_NAME)
                .then((cache) => cache.put(event.request, responseToCache));
            }
            return response;
          })
          .catch(() => cachedResponse || handleOffline(event.request));

        return cachedResponse || fetchPromise;
      })
  `,
  "network-only": `
    fetch(event.request)
      .catch(() => handleOffline(event.request))
  `,
  "cache-only": `
    caches.match(event.request)
      .then((cachedResponse) => {
        return cachedResponse || handleOffline(event.request);
      })
  `,
};

const WORKBOX_TEMPLATE = `// Service Worker with Workbox - Generated by pwa-development skill
import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { CacheFirst, NetworkFirst, StaleWhileRevalidate, NetworkOnly } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

// Precache static assets (populated by build tool)
precacheAndRoute(self.__WB_MANIFEST || []);

{{ROUTE_REGISTRATIONS}}

// Offline fallback
import { setCatchHandler } from 'workbox-routing';
import { matchPrecache } from 'workbox-precaching';

setCatchHandler(async ({ request }) => {
  if (request.destination === 'document') {
    return matchPrecache('{{OFFLINE_FALLBACK}}');
  }
  return Response.error();
});

{{SKIP_WAITING}}
{{CLIENTS_CLAIM}}
`;

const VITE_PWA_CONFIG_TEMPLATE = `// vite.config.ts PWA configuration
import { VitePWA } from 'vite-plugin-pwa';

export default defineConfig({
  plugins: [
    VitePWA({
      registerType: '{{REGISTER_TYPE}}',
      includeAssets: ['favicon.ico', 'apple-touch-icon.png', 'mask-icon.svg'],
      manifest: {
        name: 'Your App Name',
        short_name: 'App',
        description: 'Your app description',
        theme_color: '#ffffff',
        icons: [
          {
            src: 'pwa-192x192.png',
            sizes: '192x192',
            type: 'image/png'
          },
          {
            src: 'pwa-512x512.png',
            sizes: '512x512',
            type: 'image/png'
          }
        ]
      },
      workbox: {
        globPatterns: ['**/*.{js,css,html,ico,png,svg}'],
        runtimeCaching: [
{{RUNTIME_CACHING}}
        ]
      }
    })
  ]
});
`;

const SVELTEKIT_TEMPLATE = `// src/service-worker.ts - SvelteKit Service Worker
/// <reference types="@sveltejs/kit" />
/// <reference no-default-lib="true"/>
/// <reference lib="esnext" />
/// <reference lib="webworker" />

import { build, files, version } from '$service-worker';

const sw = self as unknown as ServiceWorkerGlobalScope;

const CACHE_NAME = \`cache-\${version}\`;

const ASSETS = [
  ...build, // the app itself
  ...files  // static files
];

// Install - cache all static assets
sw.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => cache.addAll(ASSETS))
      .then(() => {
        {{SKIP_WAITING}}
      })
  );
});

// Activate - clean up old caches
sw.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys()
      .then((keys) => {
        return Promise.all(
          keys
            .filter((key) => key !== CACHE_NAME)
            .map((key) => caches.delete(key))
        );
      })
      .then(() => {
        {{CLIENTS_CLAIM}}
      })
  );
});

// Fetch - {{STRATEGY}} strategy
sw.addEventListener('fetch', (event) => {
  if (event.request.method !== 'GET') return;

  event.respondWith(
    {{FETCH_HANDLER}}
  );
});
`;

// === GENERATION ===

function generateVanilla(config: ScaffolderConfig): string {
  let output = VANILLA_TEMPLATE;

  output = output.replace("{{STRATEGY}}", config.strategy);
  output = output.replace("{{CACHE_NAME}}", config.cacheName || "app-cache");
  output = output.replace("{{OFFLINE_FALLBACK}}", config.offlineFallback || "/offline.html");

  const precacheUrls = config.precacheUrls || ["/", "/offline.html"];
  output = output.replace(
    "{{PRECACHE_URLS}}",
    precacheUrls.map(url => `  '${url}',`).join("\n")
  );

  output = output.replace(
    "{{SKIP_WAITING}}",
    config.skipWaiting ? "self.skipWaiting();" : "// Call self.skipWaiting() to activate immediately"
  );

  output = output.replace(
    "{{CLIENTS_CLAIM}}",
    config.clientsClaim ? "self.clients.claim();" : "// Call self.clients.claim() to take control immediately"
  );

  output = output.replace("{{FETCH_HANDLER}}", FETCH_HANDLERS[config.strategy]);

  return output;
}

function generateWorkbox(config: ScaffolderConfig): string {
  let output = WORKBOX_TEMPLATE;

  output = output.replace("{{OFFLINE_FALLBACK}}", config.offlineFallback || "/offline.html");

  // Generate route registrations
  const routes = config.routes || [
    { pattern: "/api/", strategy: "network-first" as CachingStrategy, cacheName: "api-cache", maxAge: 60 },
    { pattern: /\.(png|jpg|jpeg|svg|gif|webp)$/.toString(), strategy: "cache-first" as CachingStrategy, cacheName: "image-cache", maxEntries: 50 },
    { pattern: /\.(js|css)$/.toString(), strategy: "stale-while-revalidate" as CachingStrategy, cacheName: "static-cache" },
  ];

  const routeRegistrations = routes.map(route => {
    const strategyClass = {
      "cache-first": "CacheFirst",
      "network-first": "NetworkFirst",
      "stale-while-revalidate": "StaleWhileRevalidate",
      "network-only": "NetworkOnly",
      "cache-only": "CacheFirst", // Workbox doesn't have CacheOnly, use CacheFirst with networkTimeoutSeconds: 0
    }[route.strategy];

    const plugins: string[] = [];
    if (route.maxEntries) {
      plugins.push(`new ExpirationPlugin({ maxEntries: ${route.maxEntries} })`);
    }
    if (route.maxAge) {
      plugins.push(`new ExpirationPlugin({ maxAgeSeconds: ${route.maxAge} })`);
    }
    plugins.push("new CacheableResponsePlugin({ statuses: [0, 200] })");

    const pattern = route.pattern.startsWith("/")
      ? `({ url }) => url.pathname.startsWith('${route.pattern}')`
      : route.pattern;

    return `
registerRoute(
  ${pattern},
  new ${strategyClass}({
    cacheName: '${route.cacheName || "runtime-cache"}',
    plugins: [
      ${plugins.join(",\n      ")}
    ]
  })
);`;
  }).join("\n");

  output = output.replace("{{ROUTE_REGISTRATIONS}}", routeRegistrations);

  output = output.replace(
    "{{SKIP_WAITING}}",
    config.skipWaiting ? "self.skipWaiting();" : ""
  );

  output = output.replace(
    "{{CLIENTS_CLAIM}}",
    config.clientsClaim ? "self.clients.claim();" : ""
  );

  return output;
}

function generateVitePwaConfig(config: ScaffolderConfig): string {
  let output = VITE_PWA_CONFIG_TEMPLATE;

  output = output.replace(
    "{{REGISTER_TYPE}}",
    config.skipWaiting ? "autoUpdate" : "prompt"
  );

  // Generate runtime caching config
  const routes = config.routes || [
    { pattern: "/api/", strategy: "network-first" as CachingStrategy },
  ];

  const runtimeCaching = routes.map(route => {
    const handler = {
      "cache-first": "CacheFirst",
      "network-first": "NetworkFirst",
      "stale-while-revalidate": "StaleWhileRevalidate",
      "network-only": "NetworkOnly",
      "cache-only": "CacheOnly",
    }[route.strategy];

    return `          {
            urlPattern: ${route.pattern.startsWith("/") ? `new RegExp('^${route.pattern}')` : route.pattern},
            handler: '${handler}',
            options: {
              cacheName: '${route.cacheName || "runtime-cache"}',
              expiration: {
                maxEntries: ${route.maxEntries || 10},
                maxAgeSeconds: ${route.maxAge || 60 * 60 * 24}
              }
            }
          }`;
  }).join(",\n");

  output = output.replace("{{RUNTIME_CACHING}}", runtimeCaching);

  return output;
}

function generateSvelteKit(config: ScaffolderConfig): string {
  let output = SVELTEKIT_TEMPLATE;

  output = output.replace("{{STRATEGY}}", config.strategy);

  output = output.replace(
    "{{SKIP_WAITING}}",
    config.skipWaiting ? "sw.skipWaiting();" : ""
  );

  output = output.replace(
    "{{CLIENTS_CLAIM}}",
    config.clientsClaim ? "sw.clients.claim();" : ""
  );

  // Adapt fetch handler for SvelteKit
  const fetchHandler = FETCH_HANDLERS[config.strategy]
    .replace(/self\./g, "sw.")
    .replace(/FULL_CACHE_NAME/g, "CACHE_NAME");

  output = output.replace("{{FETCH_HANDLER}}", fetchHandler);

  return output;
}

function generate(config: ScaffolderConfig): string {
  switch (config.framework) {
    case "vanilla":
      return generateVanilla(config);
    case "workbox":
      return generateWorkbox(config);
    case "vite-pwa":
      return generateVitePwaConfig(config);
    case "sveltekit":
      return generateSvelteKit(config);
    default:
      return generateVanilla(config);
  }
}

// === ARGUMENT PARSING ===

function parseArgs(args: string[]): { config: ScaffolderConfig; output?: string } {
  const config: ScaffolderConfig = {
    strategy: "cache-first",
    framework: "vanilla",
    skipWaiting: false,
    clientsClaim: false,
  };
  let output: string | undefined;

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    const nextArg = args[i + 1];

    switch (arg) {
      case "--help":
      case "-h":
        printHelp();
        Deno.exit(0);
        break;
      case "--strategy":
      case "-s":
        config.strategy = nextArg as CachingStrategy;
        i++;
        break;
      case "--framework":
      case "-f":
        config.framework = nextArg as Framework;
        i++;
        break;
      case "--cache-name":
        config.cacheName = nextArg;
        i++;
        break;
      case "--offline-fallback":
        config.offlineFallback = nextArg;
        i++;
        break;
      case "--skip-waiting":
        config.skipWaiting = true;
        break;
      case "--clients-claim":
        config.clientsClaim = true;
        break;
      case "--output":
      case "-o":
        output = nextArg;
        i++;
        break;
      case "--routes":
        try {
          const routesContent = Deno.readTextFileSync(nextArg);
          config.routes = JSON.parse(routesContent);
        } catch {
          console.error(`Error reading routes file: ${nextArg}`);
          Deno.exit(1);
        }
        i++;
        break;
    }
  }

  return { config, output };
}

function printHelp(): void {
  console.log(`
Service Worker Scaffolder

Generate service worker code with various caching strategies and frameworks.

USAGE:
  sw-scaffolder.ts [OPTIONS]

OPTIONS:
  --strategy, -s <strategy>    Caching strategy:
                               cache-first, network-first, stale-while-revalidate,
                               network-only, cache-only (default: cache-first)

  --framework, -f <framework>  Target framework:
                               vanilla, workbox, vite-pwa, sveltekit (default: vanilla)

  --cache-name <name>          Cache name prefix (default: app-cache)
  --offline-fallback <path>    Offline fallback page (default: /offline.html)
  --skip-waiting               Call skipWaiting() immediately
  --clients-claim              Call clients.claim() on activate
  --routes <file>              JSON file with route configurations
  --output, -o <file>          Output file path (default: stdout)
  --help, -h                   Show this help

STRATEGIES:
  cache-first              Check cache first, then network (static assets)
  network-first            Try network first, fall back to cache (API calls)
  stale-while-revalidate   Return cache immediately, update in background
  network-only             Always fetch from network
  cache-only               Only serve from cache

FRAMEWORKS:
  vanilla     Plain JavaScript service worker
  workbox     Workbox-based service worker with imports
  vite-pwa    Vite PWA plugin configuration snippet
  sveltekit   SvelteKit-compatible service worker

EXAMPLES:
  # Basic cache-first service worker
  sw-scaffolder.ts --strategy cache-first -o sw.js

  # Workbox with network-first for APIs
  sw-scaffolder.ts --framework workbox --strategy network-first -o sw.js

  # Vite PWA configuration
  sw-scaffolder.ts --framework vite-pwa --skip-waiting

  # SvelteKit with custom routes
  sw-scaffolder.ts --framework sveltekit --routes routes.json -o src/service-worker.ts
`);
}

// === MAIN ===

async function main(): Promise<void> {
  const { config, output } = parseArgs(Deno.args);

  const code = generate(config);

  if (output) {
    await Deno.writeTextFile(output, code);
    console.log(`Service worker written to ${output}`);
    console.log(`\nConfiguration:`);
    console.log(`  Strategy: ${config.strategy}`);
    console.log(`  Framework: ${config.framework}`);
    console.log(`  Skip Waiting: ${config.skipWaiting}`);
    console.log(`  Clients Claim: ${config.clientsClaim}`);
  } else {
    console.log(code);
  }
}

main();
